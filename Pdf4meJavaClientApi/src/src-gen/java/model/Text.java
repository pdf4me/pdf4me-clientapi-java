/*
 * DmsApi
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import model.Color;
import model.Rotate;
import model.Transform;
import model.Translate;
import java.io.IOException;

/**
 * Text
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-06-04T10:27:16.545+02:00")
public class Text {
  @SerializedName("format")
  private Boolean format = null;

  @SerializedName("size")
  private Integer size = null;

  @SerializedName("font")
  private String font = null;

  @SerializedName("color")
  private Color color = null;

  /**
   * Gets or Sets fontEncoding
   */
  @JsonAdapter(FontEncodingEnum.Adapter.class)
  public enum FontEncodingEnum {
    UNICODE("unicode"),
    
    WINANSI("winAnsi");

    private String value;

    FontEncodingEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FontEncodingEnum fromValue(String text) {
      for (FontEncodingEnum b : FontEncodingEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<FontEncodingEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FontEncodingEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FontEncodingEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return FontEncodingEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("fontEncoding")
  private FontEncodingEnum fontEncoding = null;

  @SerializedName("value")
  private String value = null;

  /**
   * Gets or Sets mode
   */
  @JsonAdapter(ModeEnum.Adapter.class)
  public enum ModeEnum {
    FILL("fill"),
    
    STROKE("stroke");

    private String value;

    ModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ModeEnum fromValue(String text) {
      for (ModeEnum b : ModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ModeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("mode")
  private ModeEnum mode = null;

  @SerializedName("rotate")
  private Rotate rotate = null;

  @SerializedName("translate")
  private Translate translate = null;

  @SerializedName("transform")
  private Transform transform = null;

  public Text format(Boolean format) {
    this.format = format;
    return this;
  }

   /**
   * Get format
   * @return format
  **/
  @ApiModelProperty(value = "")
  public Boolean isFormat() {
    return format;
  }

  public void setFormat(Boolean format) {
    this.format = format;
  }

  public Text size(Integer size) {
    this.size = size;
    return this;
  }

   /**
   * The font size in points, e.g. 12. If set to 0, the size is chosen such that text fits stamp size (not allowed if operator is within transformation operator).
   * @return size
  **/
  @ApiModelProperty(value = "The font size in points, e.g. 12. If set to 0, the size is chosen such that text fits stamp size (not allowed if operator is within transformation operator).")
  public Integer getSize() {
    return size;
  }

  public void setSize(Integer size) {
    this.size = size;
  }

  public Text font(String font) {
    this.font = font;
    return this;
  }

   /**
   * Get font
   * @return font
  **/
  @ApiModelProperty(value = "")
  public String getFont() {
    return font;
  }

  public void setFont(String font) {
    this.font = font;
  }

  public Text color(Color color) {
    this.color = color;
    return this;
  }

   /**
   * Get color
   * @return color
  **/
  @ApiModelProperty(value = "")
  public Color getColor() {
    return color;
  }

  public void setColor(Color color) {
    this.color = color;
  }

  public Text fontEncoding(FontEncodingEnum fontEncoding) {
    this.fontEncoding = fontEncoding;
    return this;
  }

   /**
   * Get fontEncoding
   * @return fontEncoding
  **/
  @ApiModelProperty(value = "")
  public FontEncodingEnum getFontEncoding() {
    return fontEncoding;
  }

  public void setFontEncoding(FontEncodingEnum fontEncoding) {
    this.fontEncoding = fontEncoding;
  }

  public Text value(String value) {
    this.value = value;
    return this;
  }

   /**
   * Get value
   * @return value
  **/
  @ApiModelProperty(required = true, value = "")
  public String getValue() {
    return value;
  }

  public void setValue(String value) {
    this.value = value;
  }

  public Text mode(ModeEnum mode) {
    this.mode = mode;
    return this;
  }

   /**
   * Get mode
   * @return mode
  **/
  @ApiModelProperty(value = "")
  public ModeEnum getMode() {
    return mode;
  }

  public void setMode(ModeEnum mode) {
    this.mode = mode;
  }

  public Text rotate(Rotate rotate) {
    this.rotate = rotate;
    return this;
  }

   /**
   * Get rotate
   * @return rotate
  **/
  @ApiModelProperty(value = "")
  public Rotate getRotate() {
    return rotate;
  }

  public void setRotate(Rotate rotate) {
    this.rotate = rotate;
  }

  public Text translate(Translate translate) {
    this.translate = translate;
    return this;
  }

   /**
   * Get translate
   * @return translate
  **/
  @ApiModelProperty(value = "")
  public Translate getTranslate() {
    return translate;
  }

  public void setTranslate(Translate translate) {
    this.translate = translate;
  }

  public Text transform(Transform transform) {
    this.transform = transform;
    return this;
  }

   /**
   * Get transform
   * @return transform
  **/
  @ApiModelProperty(value = "")
  public Transform getTransform() {
    return transform;
  }

  public void setTransform(Transform transform) {
    this.transform = transform;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Text text = (Text) o;
    return Objects.equals(this.format, text.format) &&
        Objects.equals(this.size, text.size) &&
        Objects.equals(this.font, text.font) &&
        Objects.equals(this.color, text.color) &&
        Objects.equals(this.fontEncoding, text.fontEncoding) &&
        Objects.equals(this.value, text.value) &&
        Objects.equals(this.mode, text.mode) &&
        Objects.equals(this.rotate, text.rotate) &&
        Objects.equals(this.translate, text.translate) &&
        Objects.equals(this.transform, text.transform);
  }

  @Override
  public int hashCode() {
    return Objects.hash(format, size, font, color, fontEncoding, value, mode, rotate, translate, transform);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Text {\n");
    
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("    font: ").append(toIndentedString(font)).append("\n");
    sb.append("    color: ").append(toIndentedString(color)).append("\n");
    sb.append("    fontEncoding: ").append(toIndentedString(fontEncoding)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("    mode: ").append(toIndentedString(mode)).append("\n");
    sb.append("    rotate: ").append(toIndentedString(rotate)).append("\n");
    sb.append("    translate: ").append(toIndentedString(translate)).append("\n");
    sb.append("    transform: ").append(toIndentedString(transform)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

