/*
 * DmsApi
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import model.KeyValuePairStringString;
import model.PdfFont;

/**
 * The CreatePdfA accepts files from many different applications and automatically   converts them into PDF/A. The level of conformity can be set to level A, U, or B. ICC color profiles for   device-dependent color profiles and font types are embedded in the document.There is an option to provide   the entire character set for fonts (no subsetting) to facilitate editing at a later stage. Missing fonts   are reproduced as close to the original as possible via font recognition. Metadata can be generated   automatically or added from external sources. The tool also detects and automatically repairs problems   typical of the PDF format.A digital signature can be applied and a conformity check carried out at the   end of the process.
 */
@ApiModel(description = "The CreatePdfA accepts files from many different applications and automatically   converts them into PDF/A. The level of conformity can be set to level A, U, or B. ICC color profiles for   device-dependent color profiles and font types are embedded in the document.There is an option to provide   the entire character set for fonts (no subsetting) to facilitate editing at a later stage. Missing fonts   are reproduced as close to the original as possible via font recognition. Metadata can be generated   automatically or added from external sources. The tool also detects and automatically repairs problems   typical of the PDF format.A digital signature can be applied and a conformity check carried out at the   end of the process.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-12-01T18:17:38.351+01:00")
public class PdfAAction {
  @SerializedName("fontsToSubset")
  private List<PdfFont> fontsToSubset = null;

  /**
   * Other listed entries (e.g. ePDF10, ePDF11, .. .ePDF17, ePDFUnk) are not supported as output compliance   level.  Some files cannot be converted to the compliance requested. This will be  detected and up- (AllowUpgrade) or downgrade (AllowDowngrade) the compliance automatically.
   */
  @JsonAdapter(ComplianceEnum.Adapter.class)
  public enum ComplianceEnum {
    PDFA1B("pdfA1b"),
    
    PDFA1A("pdfA1a"),
    
    PDFA2B("pdfA2b"),
    
    PDFA2U("pdfA2u"),
    
    PDFA2A("pdfA2a"),
    
    PDFA3B("pdfA3b"),
    
    PDFA3U("pdfA3u"),
    
    PDFA3A("pdfA3a");

    private String value;

    ComplianceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ComplianceEnum fromValue(String text) {
      for (ComplianceEnum b : ComplianceEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ComplianceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ComplianceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ComplianceEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ComplianceEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("compliance")
  private ComplianceEnum compliance = null;

  @SerializedName("allowDowngrade")
  private Boolean allowDowngrade = null;

  @SerializedName("allowUpgrade")
  private Boolean allowUpgrade = null;

  /**
   * &lt;para&gt;              Set or get the path to the ICC profile for the output intent.              &lt;/para&gt;  &lt;para&gt;              The given profile is embedded only if the input file does not contain a PDF/A output intent already              &lt;/para&gt;
   */
  @JsonAdapter(OutputIntentProfileEnum.Adapter.class)
  public enum OutputIntentProfileEnum {
    NOTSET("notSet"),
    
    SRGBCOLORSPACE("sRGBColorSpace");

    private String value;

    OutputIntentProfileEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static OutputIntentProfileEnum fromValue(String text) {
      for (OutputIntentProfileEnum b : OutputIntentProfileEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<OutputIntentProfileEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final OutputIntentProfileEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public OutputIntentProfileEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return OutputIntentProfileEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("outputIntentProfile")
  private OutputIntentProfileEnum outputIntentProfile = null;

  @SerializedName("linearize")
  private Boolean linearize = null;

  @SerializedName("customProperties")
  private List<KeyValuePairStringString> customProperties = null;

  public PdfAAction fontsToSubset(List<PdfFont> fontsToSubset) {
    this.fontsToSubset = fontsToSubset;
    return this;
  }

  public PdfAAction addFontsToSubsetItem(PdfFont fontsToSubsetItem) {
    if (this.fontsToSubset == null) {
      this.fontsToSubset = new ArrayList<PdfFont>();
    }
    this.fontsToSubset.add(fontsToSubsetItem);
    return this;
  }

   /**
   * By default, fonts that are embedded are automatically subset to minimize the file size.   If for any reason, e.g. postprocessing, fonts shall not be subset, set the property   SubsetFonts to false. Whether fonts are subset or not is irrelevant with respect to   the compliance with PDF/A. (Relevant is only that all used glyphs are contained in the font program.)   Additionals Fonts can be given in this FontsToSubset List
   * @return fontsToSubset
  **/
  @ApiModelProperty(value = "By default, fonts that are embedded are automatically subset to minimize the file size.   If for any reason, e.g. postprocessing, fonts shall not be subset, set the property   SubsetFonts to false. Whether fonts are subset or not is irrelevant with respect to   the compliance with PDF/A. (Relevant is only that all used glyphs are contained in the font program.)   Additionals Fonts can be given in this FontsToSubset List")
  public List<PdfFont> getFontsToSubset() {
    return fontsToSubset;
  }

  public void setFontsToSubset(List<PdfFont> fontsToSubset) {
    this.fontsToSubset = fontsToSubset;
  }

  public PdfAAction compliance(ComplianceEnum compliance) {
    this.compliance = compliance;
    return this;
  }

   /**
   * Other listed entries (e.g. ePDF10, ePDF11, .. .ePDF17, ePDFUnk) are not supported as output compliance   level.  Some files cannot be converted to the compliance requested. This will be  detected and up- (AllowUpgrade) or downgrade (AllowDowngrade) the compliance automatically.
   * @return compliance
  **/
  @ApiModelProperty(value = "Other listed entries (e.g. ePDF10, ePDF11, .. .ePDF17, ePDFUnk) are not supported as output compliance   level.  Some files cannot be converted to the compliance requested. This will be  detected and up- (AllowUpgrade) or downgrade (AllowDowngrade) the compliance automatically.")
  public ComplianceEnum getCompliance() {
    return compliance;
  }

  public void setCompliance(ComplianceEnum compliance) {
    this.compliance = compliance;
  }

  public PdfAAction allowDowngrade(Boolean allowDowngrade) {
    this.allowDowngrade = allowDowngrade;
    return this;
  }

   /**
   * If set to True, automatic downgrade of the PDF/A conformance level is allowed, e.g. from PDF/A-1a to PDF/A-1b.  If this property is set to True, the level is downgraded under the following conditions:    - Downgrade to level B: If a file contains text that is not extractable (i.e.missing ToUnicode information).  Example: Downgrade PDF/A-2u to PDF/A-2b.  - Downgrade to level U (PDF/A-2 and PDF/A-3) or B(PDF/A-1): Level A requires logical structure information and  “tagging” information, so if a file contains no such information, its level is downgraded.  &lt;para&gt;  Logical structure information in a PDF defines the structure of content, such as titles, paragraphs, figures, reading order, tables or articles.Logical structure elements can be “tagged” with descriptions or alternative text.  “Tagging” allows the contents of an image to be described to the visually impaired.  It is not possible for Pdf/A converter to add meaningful tagging information. Adding  tagging information without prior knowledge about the input file’s structure and content is neither possible nor  allowed by the PDF/A standard. For that reason, the conformance level is automatically downgraded to level B or U.  Example: Downgrade PDF/A-1a to PDF/A-1b.  &lt;/para&gt;&lt;para&gt;  If set to False and an input file cannot be converted to the requested standard, e.g.because of missing “tagging”  information, the conversion is aborted and the ErrorCode set to PDF_E_DOWNGRADE.  &lt;/para&gt;
   * @return allowDowngrade
  **/
  @ApiModelProperty(value = "If set to True, automatic downgrade of the PDF/A conformance level is allowed, e.g. from PDF/A-1a to PDF/A-1b.  If this property is set to True, the level is downgraded under the following conditions:    - Downgrade to level B: If a file contains text that is not extractable (i.e.missing ToUnicode information).  Example: Downgrade PDF/A-2u to PDF/A-2b.  - Downgrade to level U (PDF/A-2 and PDF/A-3) or B(PDF/A-1): Level A requires logical structure information and  “tagging” information, so if a file contains no such information, its level is downgraded.  <para>  Logical structure information in a PDF defines the structure of content, such as titles, paragraphs, figures, reading order, tables or articles.Logical structure elements can be “tagged” with descriptions or alternative text.  “Tagging” allows the contents of an image to be described to the visually impaired.  It is not possible for Pdf/A converter to add meaningful tagging information. Adding  tagging information without prior knowledge about the input file’s structure and content is neither possible nor  allowed by the PDF/A standard. For that reason, the conformance level is automatically downgraded to level B or U.  Example: Downgrade PDF/A-1a to PDF/A-1b.  </para><para>  If set to False and an input file cannot be converted to the requested standard, e.g.because of missing “tagging”  information, the conversion is aborted and the ErrorCode set to PDF_E_DOWNGRADE.  </para>")
  public Boolean isAllowDowngrade() {
    return allowDowngrade;
  }

  public void setAllowDowngrade(Boolean allowDowngrade) {
    this.allowDowngrade = allowDowngrade;
  }

  public PdfAAction allowUpgrade(Boolean allowUpgrade) {
    this.allowUpgrade = allowUpgrade;
    return this;
  }

   /**
   *  If set to True, automatic upgrade of the PDF/A version is allowed. If the target standard is PDF/A-1 and a file  contains elements that cannot be converted to PDF/A-1, the target standard is upgraded to PDF/A-2. This avoids  significant visual differences in the output file.  For example, the following elements may lead to an automatic upgrade:  - Transpanrecy  - Optional content groups(OCG, layers)  - Real values that exceed the implementation limit of PDF/A-1  - Embedded OpenType font files  - Predefined CMap encodings in Type0 fonts     If set to False, the compliance is not upgraded.Depeding on the value of the ConversionErrorMask the  conversion this will fail with a conversion error PDF_E_CONVERSION
   * @return allowUpgrade
  **/
  @ApiModelProperty(value = " If set to True, automatic upgrade of the PDF/A version is allowed. If the target standard is PDF/A-1 and a file  contains elements that cannot be converted to PDF/A-1, the target standard is upgraded to PDF/A-2. This avoids  significant visual differences in the output file.  For example, the following elements may lead to an automatic upgrade:  - Transpanrecy  - Optional content groups(OCG, layers)  - Real values that exceed the implementation limit of PDF/A-1  - Embedded OpenType font files  - Predefined CMap encodings in Type0 fonts     If set to False, the compliance is not upgraded.Depeding on the value of the ConversionErrorMask the  conversion this will fail with a conversion error PDF_E_CONVERSION")
  public Boolean isAllowUpgrade() {
    return allowUpgrade;
  }

  public void setAllowUpgrade(Boolean allowUpgrade) {
    this.allowUpgrade = allowUpgrade;
  }

  public PdfAAction outputIntentProfile(OutputIntentProfileEnum outputIntentProfile) {
    this.outputIntentProfile = outputIntentProfile;
    return this;
  }

   /**
   * &lt;para&gt;              Set or get the path to the ICC profile for the output intent.              &lt;/para&gt;  &lt;para&gt;              The given profile is embedded only if the input file does not contain a PDF/A output intent already              &lt;/para&gt;
   * @return outputIntentProfile
  **/
  @ApiModelProperty(value = "<para>              Set or get the path to the ICC profile for the output intent.              </para>  <para>              The given profile is embedded only if the input file does not contain a PDF/A output intent already              </para>")
  public OutputIntentProfileEnum getOutputIntentProfile() {
    return outputIntentProfile;
  }

  public void setOutputIntentProfile(OutputIntentProfileEnum outputIntentProfile) {
    this.outputIntentProfile = outputIntentProfile;
  }

  public PdfAAction linearize(Boolean linearize) {
    this.linearize = linearize;
    return this;
  }

   /**
   * &lt;para&gt;              Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.              A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:              - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire               PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the firstpage can be displayed.              - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as              data arrives, without downloading the entire PDF file.              &lt;/para&gt;  &lt;para&gt;              Signed files cannot be linearizes.So this property must be set to False if              a digital signature is applied.              &lt;/para&gt;
   * @return linearize
  **/
  @ApiModelProperty(value = "<para>              Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.              A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:              - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire               PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the firstpage can be displayed.              - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as              data arrives, without downloading the entire PDF file.              </para>  <para>              Signed files cannot be linearizes.So this property must be set to False if              a digital signature is applied.              </para>")
  public Boolean isLinearize() {
    return linearize;
  }

  public void setLinearize(Boolean linearize) {
    this.linearize = linearize;
  }

  public PdfAAction customProperties(List<KeyValuePairStringString> customProperties) {
    this.customProperties = customProperties;
    return this;
  }

  public PdfAAction addCustomPropertiesItem(KeyValuePairStringString customPropertiesItem) {
    if (this.customProperties == null) {
      this.customProperties = new ArrayList<KeyValuePairStringString>();
    }
    this.customProperties.add(customPropertiesItem);
    return this;
  }

   /**
   * Get customProperties
   * @return customProperties
  **/
  @ApiModelProperty(value = "")
  public List<KeyValuePairStringString> getCustomProperties() {
    return customProperties;
  }

  public void setCustomProperties(List<KeyValuePairStringString> customProperties) {
    this.customProperties = customProperties;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PdfAAction pdfAAction = (PdfAAction) o;
    return Objects.equals(this.fontsToSubset, pdfAAction.fontsToSubset) &&
        Objects.equals(this.compliance, pdfAAction.compliance) &&
        Objects.equals(this.allowDowngrade, pdfAAction.allowDowngrade) &&
        Objects.equals(this.allowUpgrade, pdfAAction.allowUpgrade) &&
        Objects.equals(this.outputIntentProfile, pdfAAction.outputIntentProfile) &&
        Objects.equals(this.linearize, pdfAAction.linearize) &&
        Objects.equals(this.customProperties, pdfAAction.customProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(fontsToSubset, compliance, allowDowngrade, allowUpgrade, outputIntentProfile, linearize, customProperties);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PdfAAction {\n");
    
    sb.append("    fontsToSubset: ").append(toIndentedString(fontsToSubset)).append("\n");
    sb.append("    compliance: ").append(toIndentedString(compliance)).append("\n");
    sb.append("    allowDowngrade: ").append(toIndentedString(allowDowngrade)).append("\n");
    sb.append("    allowUpgrade: ").append(toIndentedString(allowUpgrade)).append("\n");
    sb.append("    outputIntentProfile: ").append(toIndentedString(outputIntentProfile)).append("\n");
    sb.append("    linearize: ").append(toIndentedString(linearize)).append("\n");
    sb.append("    customProperties: ").append(toIndentedString(customProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

