/*
 * DmsApi
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import model.KeyValuePairStringString;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * OptimizeAction
 */
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-06-04T10:27:16.545+02:00")
public class OptimizeAction {
  /**
   * With this property one of the predefined optimization profiles can be set. If a profile is set then all the properties  listed in TPDFOptimizationProfile(table Profile Settings) are set to their respective values.Properties not  listed in this table are left unchanged.  One way of quickly arriving at a specific setting is to first set the Profile and then adapt the configuration by  setting some of the individual properties.
   */
  @JsonAdapter(ProfileEnum.Adapter.class)
  public enum ProfileEnum {
    DEFAULT("default"),
    
    WEB("web"),
    
    PRINT("print"),
    
    MAX("max");

    private String value;

    ProfileEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProfileEnum fromValue(String text) {
      for (ProfileEnum b : ProfileEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ProfileEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProfileEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProfileEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProfileEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("profile")
  private ProfileEnum profile = null;

  @SerializedName("useProfile")
  private Boolean useProfile = null;

  @SerializedName("removeRedundantObjects")
  private Boolean removeRedundantObjects = null;

  @SerializedName("subsetFonts")
  private Boolean subsetFonts = null;

  @SerializedName("optimizeResources")
  private Boolean optimizeResources = null;

  @SerializedName("forceCompressionTypes")
  private Boolean forceCompressionTypes = null;

  @SerializedName("forceRecompression")
  private Boolean forceRecompression = null;

  @SerializedName("reduceColorComplexity")
  private Boolean reduceColorComplexity = null;

  @SerializedName("mergeEmbeddedFonts")
  private Boolean mergeEmbeddedFonts = null;

  /**
   * Gets or Sets bitonalCompressions
   */
  @JsonAdapter(BitonalCompressionsEnum.Adapter.class)
  public enum BitonalCompressionsEnum {
    NONE("none"),
    
    RAW("raw"),
    
    JPEG("jPEG"),
    
    FLATE("flate"),
    
    LZW("lZW"),
    
    GROUP3("group3"),
    
    GROUP3_2D("group3_2D"),
    
    GROUP4("group4"),
    
    JBIG2("jBIG2"),
    
    JPEG2000("jPEG2000"),
    
    MRC("mRC"),
    
    SOURCE("source");

    private String value;

    BitonalCompressionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BitonalCompressionsEnum fromValue(String text) {
      for (BitonalCompressionsEnum b : BitonalCompressionsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<BitonalCompressionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BitonalCompressionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BitonalCompressionsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return BitonalCompressionsEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("bitonalCompressions")
  private List<BitonalCompressionsEnum> bitonalCompressions = null;

  @SerializedName("bitonalResolutionDPI")
  private Double bitonalResolutionDPI = null;

  @SerializedName("bitonalThresholdDPI")
  private Double bitonalThresholdDPI = null;

  @SerializedName("clipImages")
  private Boolean clipImages = null;

  /**
   * Gets or Sets continuousCompressions
   */
  @JsonAdapter(ContinuousCompressionsEnum.Adapter.class)
  public enum ContinuousCompressionsEnum {
    NONE("none"),
    
    RAW("raw"),
    
    JPEG("jPEG"),
    
    FLATE("flate"),
    
    LZW("lZW"),
    
    GROUP3("group3"),
    
    GROUP3_2D("group3_2D"),
    
    GROUP4("group4"),
    
    JBIG2("jBIG2"),
    
    JPEG2000("jPEG2000"),
    
    MRC("mRC"),
    
    SOURCE("source");

    private String value;

    ContinuousCompressionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ContinuousCompressionsEnum fromValue(String text) {
      for (ContinuousCompressionsEnum b : ContinuousCompressionsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ContinuousCompressionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ContinuousCompressionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ContinuousCompressionsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ContinuousCompressionsEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("continuousCompressions")
  private List<ContinuousCompressionsEnum> continuousCompressions = null;

  @SerializedName("linearize")
  private Boolean linearize = null;

  @SerializedName("imageQuality")
  private Integer imageQuality = null;

  /**
   * Gets or Sets indexedCompressions
   */
  @JsonAdapter(IndexedCompressionsEnum.Adapter.class)
  public enum IndexedCompressionsEnum {
    NONE("none"),
    
    RAW("raw"),
    
    JPEG("jPEG"),
    
    FLATE("flate"),
    
    LZW("lZW"),
    
    GROUP3("group3"),
    
    GROUP3_2D("group3_2D"),
    
    GROUP4("group4"),
    
    JBIG2("jBIG2"),
    
    JPEG2000("jPEG2000"),
    
    MRC("mRC"),
    
    SOURCE("source");

    private String value;

    IndexedCompressionsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IndexedCompressionsEnum fromValue(String text) {
      for (IndexedCompressionsEnum b : IndexedCompressionsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<IndexedCompressionsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IndexedCompressionsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IndexedCompressionsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return IndexedCompressionsEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("indexedCompressions")
  private List<IndexedCompressionsEnum> indexedCompressions = null;

  /**
   * This option enables or disables dithering when down-sampling bi-tonal images.  The only values supported are eDitherNone and eDitherFloydSteinberg.  Some bi-tonal images try to evoke the impression of different levels of gray   by randomly setting pixels to black.If dithering is applied during downsampling    then the gray levels of such images are preserved better.If dithering is switched    off then lines (e.g.text glyphs) are preserved better.      {default: DitherNone}
   */
  @JsonAdapter(DitheringModeEnum.Adapter.class)
  public enum DitheringModeEnum {
    NONE("none"),
    
    FLOYDSTEINBERG("floydSteinberg"),
    
    HALFTONE("halftone"),
    
    PATTERN("pattern"),
    
    G3OPTIMIZED("g3Optimized"),
    
    G4OPTIMIZED("g4Optimized"),
    
    ATKINSON("atkinson");

    private String value;

    DitheringModeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DitheringModeEnum fromValue(String text) {
      for (DitheringModeEnum b : DitheringModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<DitheringModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DitheringModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DitheringModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return DitheringModeEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("ditheringMode")
  private DitheringModeEnum ditheringMode = null;

  @SerializedName("colorResolutionDPI")
  private Double colorResolutionDPI = null;

  @SerializedName("colorThresholdDPI")
  private Double colorThresholdDPI = null;

  @SerializedName("monochromeResolutionDPI")
  private Double monochromeResolutionDPI = null;

  @SerializedName("monochromeThresholdDPI")
  private Double monochromeThresholdDPI = null;

  @SerializedName("resolutionDPI")
  private Integer resolutionDPI = null;

  @SerializedName("thresholdDPI")
  private Integer thresholdDPI = null;

  /**
   * Gets or Sets strip
   */
  @JsonAdapter(StripEnum.Adapter.class)
  public enum StripEnum {
    THREADS("threads"),
    
    METADATA("metadata"),
    
    PIECEINFO("pieceInfo"),
    
    STRUCTTREE("structTree"),
    
    THUMB("thumb"),
    
    SPIDER("spider"),
    
    ALTERNATES("alternates"),
    
    FORMS("forms"),
    
    LINKS("links"),
    
    ANNOTS("annots"),
    
    FORMSANNOTS("formsAnnots"),
    
    OUTPUTINTENTS("outputIntents"),
    
    ALL("all");

    private String value;

    StripEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StripEnum fromValue(String text) {
      for (StripEnum b : StripEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<StripEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StripEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StripEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return StripEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("strip")
  private List<StripEnum> strip = null;

  @SerializedName("infoEntries")
  private List<KeyValuePairStringString> infoEntries = null;

  @SerializedName("flattenSignatureFields")
  private Boolean flattenSignatureFields = null;

  @SerializedName("customProperties")
  private List<KeyValuePairStringString> customProperties = null;

  public OptimizeAction profile(ProfileEnum profile) {
    this.profile = profile;
    return this;
  }

   /**
   * With this property one of the predefined optimization profiles can be set. If a profile is set then all the properties  listed in TPDFOptimizationProfile(table Profile Settings) are set to their respective values.Properties not  listed in this table are left unchanged.  One way of quickly arriving at a specific setting is to first set the Profile and then adapt the configuration by  setting some of the individual properties.
   * @return profile
  **/
  @ApiModelProperty(value = "With this property one of the predefined optimization profiles can be set. If a profile is set then all the properties  listed in TPDFOptimizationProfile(table Profile Settings) are set to their respective values.Properties not  listed in this table are left unchanged.  One way of quickly arriving at a specific setting is to first set the Profile and then adapt the configuration by  setting some of the individual properties.")
  public ProfileEnum getProfile() {
    return profile;
  }

  public void setProfile(ProfileEnum profile) {
    this.profile = profile;
  }

  public OptimizeAction useProfile(Boolean useProfile) {
    this.useProfile = useProfile;
    return this;
  }

   /**
   * Get useProfile
   * @return useProfile
  **/
  @ApiModelProperty(value = "")
  public Boolean isUseProfile() {
    return useProfile;
  }

  public void setUseProfile(Boolean useProfile) {
    this.useProfile = useProfile;
  }

  public OptimizeAction removeRedundantObjects(Boolean removeRedundantObjects) {
    this.removeRedundantObjects = removeRedundantObjects;
    return this;
  }

   /**
   * Get or set whether redundant objects should be removed. If this property is  set to True, duplicate objects are removed in order to reduce the file size.    {default: false}
   * @return removeRedundantObjects
  **/
  @ApiModelProperty(value = "Get or set whether redundant objects should be removed. If this property is  set to True, duplicate objects are removed in order to reduce the file size.    {default: false}")
  public Boolean isRemoveRedundantObjects() {
    return removeRedundantObjects;
  }

  public void setRemoveRedundantObjects(Boolean removeRedundantObjects) {
    this.removeRedundantObjects = removeRedundantObjects;
  }

  public OptimizeAction subsetFonts(Boolean subsetFonts) {
    this.subsetFonts = subsetFonts;
    return this;
  }

   /**
   * This property influences two optimizations related to subsetted fonts:  - Subset embedded fonts.  - Merge embedded font programs of different subsets of the same font, granted they can be merged.   &lt;para&gt;  Sub-setting refers to removing those glyphs in a font that are not actually  used in any text contained in the PDF.   &lt;/para&gt;{default: false}
   * @return subsetFonts
  **/
  @ApiModelProperty(value = "This property influences two optimizations related to subsetted fonts:  - Subset embedded fonts.  - Merge embedded font programs of different subsets of the same font, granted they can be merged.   <para>  Sub-setting refers to removing those glyphs in a font that are not actually  used in any text contained in the PDF.   </para>{default: false}")
  public Boolean isSubsetFonts() {
    return subsetFonts;
  }

  public void setSubsetFonts(Boolean subsetFonts) {
    this.subsetFonts = subsetFonts;
  }

  public OptimizeAction optimizeResources(Boolean optimizeResources) {
    this.optimizeResources = optimizeResources;
    return this;
  }

   /**
   * Get or set whether resources should be optimized. If set, unused resources  such as images, fonts, and color spaces are removed.Also content streams  are re-built.    {default: false}
   * @return optimizeResources
  **/
  @ApiModelProperty(value = "Get or set whether resources should be optimized. If set, unused resources  such as images, fonts, and color spaces are removed.Also content streams  are re-built.    {default: false}")
  public Boolean isOptimizeResources() {
    return optimizeResources;
  }

  public void setOptimizeResources(Boolean optimizeResources) {
    this.optimizeResources = optimizeResources;
  }

  public OptimizeAction forceCompressionTypes(Boolean forceCompressionTypes) {
    this.forceCompressionTypes = forceCompressionTypes;
    return this;
  }

   /**
   * If this option is set, then re-compression of images is forced if an image in the  input PDF has a compression type that differs from the compression types  given in ContinuousCompressions, BitonalCompressions, or IndexedCompressions. Use this option if you want to allow only the given  compression types for images in the output PDF.  {default: false}
   * @return forceCompressionTypes
  **/
  @ApiModelProperty(value = "If this option is set, then re-compression of images is forced if an image in the  input PDF has a compression type that differs from the compression types  given in ContinuousCompressions, BitonalCompressions, or IndexedCompressions. Use this option if you want to allow only the given  compression types for images in the output PDF.  {default: false}")
  public Boolean isForceCompressionTypes() {
    return forceCompressionTypes;
  }

  public void setForceCompressionTypes(Boolean forceCompressionTypes) {
    this.forceCompressionTypes = forceCompressionTypes;
  }

  public OptimizeAction forceRecompression(Boolean forceRecompression) {
    this.forceRecompression = forceRecompression;
    return this;
  }

   /**
   * If set, all images are always recompressed.If not set (default), images are only  recompressed if the resulting image is smaller than the original, i.e.requires  less bytes to store in the file.    {default: false}
   * @return forceRecompression
  **/
  @ApiModelProperty(value = "If set, all images are always recompressed.If not set (default), images are only  recompressed if the resulting image is smaller than the original, i.e.requires  less bytes to store in the file.    {default: false}")
  public Boolean isForceRecompression() {
    return forceRecompression;
  }

  public void setForceRecompression(Boolean forceRecompression) {
    this.forceRecompression = forceRecompression;
  }

  public OptimizeAction reduceColorComplexity(Boolean reduceColorComplexity) {
    this.reduceColorComplexity = reduceColorComplexity;
    return this;
  }

   /**
   * This property is used to enable color complexity reduction of images. (See  also Provided Features for Optimizing Images.)  If enabled then images with device color spaces(DeviceRGB, DeviceCMYK,  or DeviceGray) and indexed images with a device color space as base color  space are analyzed and if possible converted as follows:  - An image with DeviceRGB or DeviceCMYK color space in which all pixels  are gray is converted to a grayscale image with DeviceGray color space.  - An image that contains only black and white pixels is converted into a bitonal image.  - An image in which all the pixels have the same color is down-sampled to one pixel.  Furthermore, images’ masks and soft masks are optimized as follows:  - A soft mask that contains only black and white pixels is converted to a mask.  - A (soft) mask that is opaque is removed.    {default: false}
   * @return reduceColorComplexity
  **/
  @ApiModelProperty(value = "This property is used to enable color complexity reduction of images. (See  also Provided Features for Optimizing Images.)  If enabled then images with device color spaces(DeviceRGB, DeviceCMYK,  or DeviceGray) and indexed images with a device color space as base color  space are analyzed and if possible converted as follows:  - An image with DeviceRGB or DeviceCMYK color space in which all pixels  are gray is converted to a grayscale image with DeviceGray color space.  - An image that contains only black and white pixels is converted into a bitonal image.  - An image in which all the pixels have the same color is down-sampled to one pixel.  Furthermore, images’ masks and soft masks are optimized as follows:  - A soft mask that contains only black and white pixels is converted to a mask.  - A (soft) mask that is opaque is removed.    {default: false}")
  public Boolean isReduceColorComplexity() {
    return reduceColorComplexity;
  }

  public void setReduceColorComplexity(Boolean reduceColorComplexity) {
    this.reduceColorComplexity = reduceColorComplexity;
  }

  public OptimizeAction mergeEmbeddedFonts(Boolean mergeEmbeddedFonts) {
    this.mergeEmbeddedFonts = mergeEmbeddedFonts;
    return this;
  }

   /**
   * Merge embedded font programs. Font programs can be merged, if they  originate from the same font, e.g.they are of the same type, have the same  name and encoding.Merging of Type1(PostScript) and TrueType fonts is supported.
   * @return mergeEmbeddedFonts
  **/
  @ApiModelProperty(value = "Merge embedded font programs. Font programs can be merged, if they  originate from the same font, e.g.they are of the same type, have the same  name and encoding.Merging of Type1(PostScript) and TrueType fonts is supported.")
  public Boolean isMergeEmbeddedFonts() {
    return mergeEmbeddedFonts;
  }

  public void setMergeEmbeddedFonts(Boolean mergeEmbeddedFonts) {
    this.mergeEmbeddedFonts = mergeEmbeddedFonts;
  }

  public OptimizeAction bitonalCompressions(List<BitonalCompressionsEnum> bitonalCompressions) {
    this.bitonalCompressions = bitonalCompressions;
    return this;
  }

  public OptimizeAction addBitonalCompressionsItem(BitonalCompressionsEnum bitonalCompressionsItem) {
    if (this.bitonalCompressions == null) {
      this.bitonalCompressions = new ArrayList<BitonalCompressionsEnum>();
    }
    this.bitonalCompressions.add(bitonalCompressionsItem);
    return this;
  }

   /**
   * Get or set the compression types for bi-tonal images.  Several values can be combined.The following values are allowed:  ComprAttemptNone  ComprAttemptRaw  ComprAttemptFlate  ComprAttemptLZW  ComprAttemptGroup3  ComprAttemptGroup4  ComprAttemptSource  ComprAttemptJBIG2  Other values are ignored.   &lt;para&gt;  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.  Typically, CCITT Group 4 or JBIG2 is used for bi-tonal compression. Due to the simpler algorithm CCITT Group 4 has  the advantage of being faster. JBIG2 can achieve compression ratios that are up to twice as high as CCITT Group 4  at the cost of longer computation time.   &lt;/para&gt;{default: ComprAttemptNone}
   * @return bitonalCompressions
  **/
  @ApiModelProperty(value = "Get or set the compression types for bi-tonal images.  Several values can be combined.The following values are allowed:  ComprAttemptNone  ComprAttemptRaw  ComprAttemptFlate  ComprAttemptLZW  ComprAttemptGroup3  ComprAttemptGroup4  ComprAttemptSource  ComprAttemptJBIG2  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.  Typically, CCITT Group 4 or JBIG2 is used for bi-tonal compression. Due to the simpler algorithm CCITT Group 4 has  the advantage of being faster. JBIG2 can achieve compression ratios that are up to twice as high as CCITT Group 4  at the cost of longer computation time.   </para>{default: ComprAttemptNone}")
  public List<BitonalCompressionsEnum> getBitonalCompressions() {
    return bitonalCompressions;
  }

  public void setBitonalCompressions(List<BitonalCompressionsEnum> bitonalCompressions) {
    this.bitonalCompressions = bitonalCompressions;
  }

  public OptimizeAction bitonalResolutionDPI(Double bitonalResolutionDPI) {
    this.bitonalResolutionDPI = bitonalResolutionDPI;
    return this;
  }

   /**
   * Get or set the target resolution in dots per inch (DPI) after re-sampling images  for bi-tonal images.See also ResolutionDPI.    {default: 200}
   * @return bitonalResolutionDPI
  **/
  @ApiModelProperty(value = "Get or set the target resolution in dots per inch (DPI) after re-sampling images  for bi-tonal images.See also ResolutionDPI.    {default: 200}")
  public Double getBitonalResolutionDPI() {
    return bitonalResolutionDPI;
  }

  public void setBitonalResolutionDPI(Double bitonalResolutionDPI) {
    this.bitonalResolutionDPI = bitonalResolutionDPI;
  }

  public OptimizeAction bitonalThresholdDPI(Double bitonalThresholdDPI) {
    this.bitonalThresholdDPI = bitonalThresholdDPI;
    return this;
  }

   /**
   * Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for bi-tonal images.The value -1 deactivates re-sampling for bitonal images. See also ThresholdDPI.    {default: -1}
   * @return bitonalThresholdDPI
  **/
  @ApiModelProperty(value = "Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for bi-tonal images.The value -1 deactivates re-sampling for bitonal images. See also ThresholdDPI.    {default: -1}")
  public Double getBitonalThresholdDPI() {
    return bitonalThresholdDPI;
  }

  public void setBitonalThresholdDPI(Double bitonalThresholdDPI) {
    this.bitonalThresholdDPI = bitonalThresholdDPI;
  }

  public OptimizeAction clipImages(Boolean clipImages) {
    this.clipImages = clipImages;
    return this;
  }

   /**
   * Get or set the option to clip images. When enabled, then invisible parts of images are clipped (cropped).   While this does not affect visual parts of images, it may have a minor visual impact because clipped   images are re-compressed. Pre-blended images are not clipped. Enabling this property will also   enable the OptimizeResources property.                {default: false}
   * @return clipImages
  **/
  @ApiModelProperty(value = "Get or set the option to clip images. When enabled, then invisible parts of images are clipped (cropped).   While this does not affect visual parts of images, it may have a minor visual impact because clipped   images are re-compressed. Pre-blended images are not clipped. Enabling this property will also   enable the OptimizeResources property.                {default: false}")
  public Boolean isClipImages() {
    return clipImages;
  }

  public void setClipImages(Boolean clipImages) {
    this.clipImages = clipImages;
  }

  public OptimizeAction continuousCompressions(List<ContinuousCompressionsEnum> continuousCompressions) {
    this.continuousCompressions = continuousCompressions;
    return this;
  }

  public OptimizeAction addContinuousCompressionsItem(ContinuousCompressionsEnum continuousCompressionsItem) {
    if (this.continuousCompressions == null) {
      this.continuousCompressions = new ArrayList<ContinuousCompressionsEnum>();
    }
    this.continuousCompressions.add(continuousCompressionsItem);
    return this;
  }

   /**
   * Get or set the compression types to be tried for continuous images, i.e. RGB, CMYK, and grayscale images.  See also TPDFComprAttempt. Several values can be combined with bitwise or operators.  Other values are ignored. During optimization, all set compression types are tried and the one resulting in   the least memory footprint is taken.    {default: ComprAttemptNone}
   * @return continuousCompressions
  **/
  @ApiModelProperty(value = "Get or set the compression types to be tried for continuous images, i.e. RGB, CMYK, and grayscale images.  See also TPDFComprAttempt. Several values can be combined with bitwise or operators.  Other values are ignored. During optimization, all set compression types are tried and the one resulting in   the least memory footprint is taken.    {default: ComprAttemptNone}")
  public List<ContinuousCompressionsEnum> getContinuousCompressions() {
    return continuousCompressions;
  }

  public void setContinuousCompressions(List<ContinuousCompressionsEnum> continuousCompressions) {
    this.continuousCompressions = continuousCompressions;
  }

  public OptimizeAction linearize(Boolean linearize) {
    this.linearize = linearize;
    return this;
  }

   /**
   * Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.   A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:   - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire   PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the first page can be displayed.  - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as   data arrives, without downloading the entire PDF file.   &lt;para&gt;  Signed files cannot be linearizes. So this property must be set to False if a digital signature is applied.   &lt;/para&gt;{default: false}
   * @return linearize
  **/
  @ApiModelProperty(value = "Get or set whether to linearize the PDF output file, i.e. optimize file for fast web access.   A linearized document has a slightly larger file size than a non-linearized file and provides the following main features:   - When a document is opened in a PDF viewer of a web browser, the first page can be viewed without downloading the entire   PDF file.In contrast, a non-linearized PDF file must be downloaded completely before the first page can be displayed.  - When another page is requested by the user, that page is displayed as quickly as possible and incrementally as   data arrives, without downloading the entire PDF file.   <para>  Signed files cannot be linearizes. So this property must be set to False if a digital signature is applied.   </para>{default: false}")
  public Boolean isLinearize() {
    return linearize;
  }

  public void setLinearize(Boolean linearize) {
    this.linearize = linearize;
  }

  public OptimizeAction imageQuality(Integer imageQuality) {
    this.imageQuality = imageQuality;
    return this;
  }

   /**
   * Get or set the quality index of lossy compression types. This value ranges   from 1 to 100 and is applied to JPEG and JPEG2000 compression.For  JPEG2000, a quality index of 100 means lossless compression.JPEG compression is always lossy.    {default: 75}
   * @return imageQuality
  **/
  @ApiModelProperty(value = "Get or set the quality index of lossy compression types. This value ranges   from 1 to 100 and is applied to JPEG and JPEG2000 compression.For  JPEG2000, a quality index of 100 means lossless compression.JPEG compression is always lossy.    {default: 75}")
  public Integer getImageQuality() {
    return imageQuality;
  }

  public void setImageQuality(Integer imageQuality) {
    this.imageQuality = imageQuality;
  }

  public OptimizeAction indexedCompressions(List<IndexedCompressionsEnum> indexedCompressions) {
    this.indexedCompressions = indexedCompressions;
    return this;
  }

  public OptimizeAction addIndexedCompressionsItem(IndexedCompressionsEnum indexedCompressionsItem) {
    if (this.indexedCompressions == null) {
      this.indexedCompressions = new ArrayList<IndexedCompressionsEnum>();
    }
    this.indexedCompressions.add(indexedCompressionsItem);
    return this;
  }

   /**
   * Get or set the compression types for images that have an indexed (“palette”)  color space.See also TPDFComprAttempt.  Several values can be combined with bitwise or operators.The following values are allowed:  - ComprAttemptNone  - ComprAttemptRaw  - ComprAttemptFlate  - ComprAttemptLZW  - ComprAttemptSource  Other values are ignored.   &lt;para&gt;  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.   &lt;/para&gt;{default: ComprAttemptFlate}
   * @return indexedCompressions
  **/
  @ApiModelProperty(value = "Get or set the compression types for images that have an indexed (“palette”)  color space.See also TPDFComprAttempt.  Several values can be combined with bitwise or operators.The following values are allowed:  - ComprAttemptNone  - ComprAttemptRaw  - ComprAttemptFlate  - ComprAttemptLZW  - ComprAttemptSource  Other values are ignored.   <para>  During optimization, all set compression types are tried and the one resulting in the least memory footprint is taken.   </para>{default: ComprAttemptFlate}")
  public List<IndexedCompressionsEnum> getIndexedCompressions() {
    return indexedCompressions;
  }

  public void setIndexedCompressions(List<IndexedCompressionsEnum> indexedCompressions) {
    this.indexedCompressions = indexedCompressions;
  }

  public OptimizeAction ditheringMode(DitheringModeEnum ditheringMode) {
    this.ditheringMode = ditheringMode;
    return this;
  }

   /**
   * This option enables or disables dithering when down-sampling bi-tonal images.  The only values supported are eDitherNone and eDitherFloydSteinberg.  Some bi-tonal images try to evoke the impression of different levels of gray   by randomly setting pixels to black.If dithering is applied during downsampling    then the gray levels of such images are preserved better.If dithering is switched    off then lines (e.g.text glyphs) are preserved better.      {default: DitherNone}
   * @return ditheringMode
  **/
  @ApiModelProperty(value = "This option enables or disables dithering when down-sampling bi-tonal images.  The only values supported are eDitherNone and eDitherFloydSteinberg.  Some bi-tonal images try to evoke the impression of different levels of gray   by randomly setting pixels to black.If dithering is applied during downsampling    then the gray levels of such images are preserved better.If dithering is switched    off then lines (e.g.text glyphs) are preserved better.      {default: DitherNone}")
  public DitheringModeEnum getDitheringMode() {
    return ditheringMode;
  }

  public void setDitheringMode(DitheringModeEnum ditheringMode) {
    this.ditheringMode = ditheringMode;
  }

  public OptimizeAction colorResolutionDPI(Double colorResolutionDPI) {
    this.colorResolutionDPI = colorResolutionDPI;
    return this;
  }

   /**
   * Get or set the target resolution in dots per inch (DPI) after re-sampling images  for color images.See also ResolutionDPI.    {default: 150}
   * @return colorResolutionDPI
  **/
  @ApiModelProperty(value = "Get or set the target resolution in dots per inch (DPI) after re-sampling images  for color images.See also ResolutionDPI.    {default: 150}")
  public Double getColorResolutionDPI() {
    return colorResolutionDPI;
  }

  public void setColorResolutionDPI(Double colorResolutionDPI) {
    this.colorResolutionDPI = colorResolutionDPI;
  }

  public OptimizeAction colorThresholdDPI(Double colorThresholdDPI) {
    this.colorThresholdDPI = colorThresholdDPI;
    return this;
  }

   /**
   * Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for color images.The value -1 deactivates re-sampling for color  images. See also ThresholdDPI.    {default: -1}
   * @return colorThresholdDPI
  **/
  @ApiModelProperty(value = "Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for color images.The value -1 deactivates re-sampling for color  images. See also ThresholdDPI.    {default: -1}")
  public Double getColorThresholdDPI() {
    return colorThresholdDPI;
  }

  public void setColorThresholdDPI(Double colorThresholdDPI) {
    this.colorThresholdDPI = colorThresholdDPI;
  }

  public OptimizeAction monochromeResolutionDPI(Double monochromeResolutionDPI) {
    this.monochromeResolutionDPI = monochromeResolutionDPI;
    return this;
  }

   /**
   * Get or set target resolution in dots per inch (DPI) after re-sampling images  for monochrome images.See also ResolutionDPI.    {default: 150}
   * @return monochromeResolutionDPI
  **/
  @ApiModelProperty(value = "Get or set target resolution in dots per inch (DPI) after re-sampling images  for monochrome images.See also ResolutionDPI.    {default: 150}")
  public Double getMonochromeResolutionDPI() {
    return monochromeResolutionDPI;
  }

  public void setMonochromeResolutionDPI(Double monochromeResolutionDPI) {
    this.monochromeResolutionDPI = monochromeResolutionDPI;
  }

  public OptimizeAction monochromeThresholdDPI(Double monochromeThresholdDPI) {
    this.monochromeThresholdDPI = monochromeThresholdDPI;
    return this;
  }

   /**
   * Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for monochrome images.The value -1 deactivates re-sampling  for monochrome images. See also ThresholdDPI.    {default: -1}
   * @return monochromeThresholdDPI
  **/
  @ApiModelProperty(value = "Get or set the threshold resolution in dots per inch (DPI) to selectively activate  re-sampling for monochrome images.The value -1 deactivates re-sampling  for monochrome images. See also ThresholdDPI.    {default: -1}")
  public Double getMonochromeThresholdDPI() {
    return monochromeThresholdDPI;
  }

  public void setMonochromeThresholdDPI(Double monochromeThresholdDPI) {
    this.monochromeThresholdDPI = monochromeThresholdDPI;
  }

  public OptimizeAction resolutionDPI(Integer resolutionDPI) {
    this.resolutionDPI = resolutionDPI;
    return this;
  }

   /**
   * Get or set the resolution in DPI (dots per inch) after re-sampling images.  This property affects all three image compression types(BitonalResolutionDPI, ColorResolutionDPI, MonochromeResolutionDPI).  A typical value for the resolution when optimizing for the web is 150 DPI.For  printing typically no re-sampling is applied(see property ThresholdDPI).  Pre-blended images, images with a color key mask, mask, and soft mask images are not re-sampled.  When getting ResolutionDPI, the property returns the target resolution in DPI for color images.    {default: Different defaults apply to different image types}
   * @return resolutionDPI
  **/
  @ApiModelProperty(value = "Get or set the resolution in DPI (dots per inch) after re-sampling images.  This property affects all three image compression types(BitonalResolutionDPI, ColorResolutionDPI, MonochromeResolutionDPI).  A typical value for the resolution when optimizing for the web is 150 DPI.For  printing typically no re-sampling is applied(see property ThresholdDPI).  Pre-blended images, images with a color key mask, mask, and soft mask images are not re-sampled.  When getting ResolutionDPI, the property returns the target resolution in DPI for color images.    {default: Different defaults apply to different image types}")
  public Integer getResolutionDPI() {
    return resolutionDPI;
  }

  public void setResolutionDPI(Integer resolutionDPI) {
    this.resolutionDPI = resolutionDPI;
  }

  public OptimizeAction thresholdDPI(Integer thresholdDPI) {
    this.thresholdDPI = thresholdDPI;
    return this;
  }

   /**
   * Set the threshold in DPI (dots per inch) to selectively activate re-sampling.  Only images with a resolution above the threshold DPI will be re-sampled.  This property affects all three image compression types(BitonalThresholdDPI, ColorThresholdDPI, MonochromeThresholdDPI). The  value -1 deactivates re-sampling.    {default: -1}
   * @return thresholdDPI
  **/
  @ApiModelProperty(value = "Set the threshold in DPI (dots per inch) to selectively activate re-sampling.  Only images with a resolution above the threshold DPI will be re-sampled.  This property affects all three image compression types(BitonalThresholdDPI, ColorThresholdDPI, MonochromeThresholdDPI). The  value -1 deactivates re-sampling.    {default: -1}")
  public Integer getThresholdDPI() {
    return thresholdDPI;
  }

  public void setThresholdDPI(Integer thresholdDPI) {
    this.thresholdDPI = thresholdDPI;
  }

  public OptimizeAction strip(List<StripEnum> strip) {
    this.strip = strip;
    return this;
  }

  public OptimizeAction addStripItem(StripEnum stripItem) {
    if (this.strip == null) {
      this.strip = new ArrayList<StripEnum>();
    }
    this.strip.add(stripItem);
    return this;
  }

   /**
   *  Get or set the stripping mode. This mode can be configured to remove unneeded data of a PDF document such as Threads, Metadata, the PieceInfo,  the StructTreeRoot entry, embedded Thumbs and the SpiderInfo entry.Also  this mode is used to indicate whether to flatten form fields, links, and other  annotations.Multiple values of TPDFStripType can be combined with the  bitwise or operator.     {default: StripThreads}
   * @return strip
  **/
  @ApiModelProperty(value = " Get or set the stripping mode. This mode can be configured to remove unneeded data of a PDF document such as Threads, Metadata, the PieceInfo,  the StructTreeRoot entry, embedded Thumbs and the SpiderInfo entry.Also  this mode is used to indicate whether to flatten form fields, links, and other  annotations.Multiple values of TPDFStripType can be combined with the  bitwise or operator.     {default: StripThreads}")
  public List<StripEnum> getStrip() {
    return strip;
  }

  public void setStrip(List<StripEnum> strip) {
    this.strip = strip;
  }

  public OptimizeAction infoEntries(List<KeyValuePairStringString> infoEntries) {
    this.infoEntries = infoEntries;
    return this;
  }

  public OptimizeAction addInfoEntriesItem(KeyValuePairStringString infoEntriesItem) {
    if (this.infoEntries == null) {
      this.infoEntries = new ArrayList<KeyValuePairStringString>();
    }
    this.infoEntries.add(infoEntriesItem);
    return this;
  }

   /**
   *  Set a key-value pair in the document info dictionary. Values of predefined keys are also stored in the XMP metadata.  Popular entries specified in the PDF Reference 1.7 and accepted by most PDF viewers are \&quot;Title\&quot;, \&quot;Author\&quot;,  \&quot;Subject\&quot;, \&quot;Creator\&quot; (sometimes referred to as Application), and \&quot;Producer\&quot; (sometimes referred to as   PDF Creator).
   * @return infoEntries
  **/
  @ApiModelProperty(value = " Set a key-value pair in the document info dictionary. Values of predefined keys are also stored in the XMP metadata.  Popular entries specified in the PDF Reference 1.7 and accepted by most PDF viewers are \"Title\", \"Author\",  \"Subject\", \"Creator\" (sometimes referred to as Application), and \"Producer\" (sometimes referred to as   PDF Creator).")
  public List<KeyValuePairStringString> getInfoEntries() {
    return infoEntries;
  }

  public void setInfoEntries(List<KeyValuePairStringString> infoEntries) {
    this.infoEntries = infoEntries;
  }

  public OptimizeAction flattenSignatureFields(Boolean flattenSignatureFields) {
    this.flattenSignatureFields = flattenSignatureFields;
    return this;
  }

   /**
   * A signature in a PDF consist of two parts:  a.The invisible digital signature in the PDF.  b.The visual appearance that was attributed to the signature.  Part (a) can be used by a viewing application, to verify that a document has not changed since it has been signed  and report this to the user.Part(b) is merely a “decorative” element on the page without further significance.  When optimizing a PDF, the PDF is altered and hence the digital signature is broken.Therefore, all signatures are removed  , including parts(a) and(b).  When the property FlattenSignatureFields is set to True, then digital signatures(parts (a)) are still removed,  but their visual appearances(parts (b)) are flattened.I.e.the latter are retained and drawn as non-editable graphic  onto the page.  &lt;para&gt;  Note: The resulting PDF can be misleading as it visually appears to be signed,  but it has no digital signature and hence, a viewer application does not report any  broken signature.In most cases, such a behavior is undesirable&lt;/para&gt;
   * @return flattenSignatureFields
  **/
  @ApiModelProperty(value = "A signature in a PDF consist of two parts:  a.The invisible digital signature in the PDF.  b.The visual appearance that was attributed to the signature.  Part (a) can be used by a viewing application, to verify that a document has not changed since it has been signed  and report this to the user.Part(b) is merely a “decorative” element on the page without further significance.  When optimizing a PDF, the PDF is altered and hence the digital signature is broken.Therefore, all signatures are removed  , including parts(a) and(b).  When the property FlattenSignatureFields is set to True, then digital signatures(parts (a)) are still removed,  but their visual appearances(parts (b)) are flattened.I.e.the latter are retained and drawn as non-editable graphic  onto the page.  <para>  Note: The resulting PDF can be misleading as it visually appears to be signed,  but it has no digital signature and hence, a viewer application does not report any  broken signature.In most cases, such a behavior is undesirable</para>")
  public Boolean isFlattenSignatureFields() {
    return flattenSignatureFields;
  }

  public void setFlattenSignatureFields(Boolean flattenSignatureFields) {
    this.flattenSignatureFields = flattenSignatureFields;
  }

  public OptimizeAction customProperties(List<KeyValuePairStringString> customProperties) {
    this.customProperties = customProperties;
    return this;
  }

  public OptimizeAction addCustomPropertiesItem(KeyValuePairStringString customPropertiesItem) {
    if (this.customProperties == null) {
      this.customProperties = new ArrayList<KeyValuePairStringString>();
    }
    this.customProperties.add(customPropertiesItem);
    return this;
  }

   /**
   * Get customProperties
   * @return customProperties
  **/
  @ApiModelProperty(value = "")
  public List<KeyValuePairStringString> getCustomProperties() {
    return customProperties;
  }

  public void setCustomProperties(List<KeyValuePairStringString> customProperties) {
    this.customProperties = customProperties;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OptimizeAction optimizeAction = (OptimizeAction) o;
    return Objects.equals(this.profile, optimizeAction.profile) &&
        Objects.equals(this.useProfile, optimizeAction.useProfile) &&
        Objects.equals(this.removeRedundantObjects, optimizeAction.removeRedundantObjects) &&
        Objects.equals(this.subsetFonts, optimizeAction.subsetFonts) &&
        Objects.equals(this.optimizeResources, optimizeAction.optimizeResources) &&
        Objects.equals(this.forceCompressionTypes, optimizeAction.forceCompressionTypes) &&
        Objects.equals(this.forceRecompression, optimizeAction.forceRecompression) &&
        Objects.equals(this.reduceColorComplexity, optimizeAction.reduceColorComplexity) &&
        Objects.equals(this.mergeEmbeddedFonts, optimizeAction.mergeEmbeddedFonts) &&
        Objects.equals(this.bitonalCompressions, optimizeAction.bitonalCompressions) &&
        Objects.equals(this.bitonalResolutionDPI, optimizeAction.bitonalResolutionDPI) &&
        Objects.equals(this.bitonalThresholdDPI, optimizeAction.bitonalThresholdDPI) &&
        Objects.equals(this.clipImages, optimizeAction.clipImages) &&
        Objects.equals(this.continuousCompressions, optimizeAction.continuousCompressions) &&
        Objects.equals(this.linearize, optimizeAction.linearize) &&
        Objects.equals(this.imageQuality, optimizeAction.imageQuality) &&
        Objects.equals(this.indexedCompressions, optimizeAction.indexedCompressions) &&
        Objects.equals(this.ditheringMode, optimizeAction.ditheringMode) &&
        Objects.equals(this.colorResolutionDPI, optimizeAction.colorResolutionDPI) &&
        Objects.equals(this.colorThresholdDPI, optimizeAction.colorThresholdDPI) &&
        Objects.equals(this.monochromeResolutionDPI, optimizeAction.monochromeResolutionDPI) &&
        Objects.equals(this.monochromeThresholdDPI, optimizeAction.monochromeThresholdDPI) &&
        Objects.equals(this.resolutionDPI, optimizeAction.resolutionDPI) &&
        Objects.equals(this.thresholdDPI, optimizeAction.thresholdDPI) &&
        Objects.equals(this.strip, optimizeAction.strip) &&
        Objects.equals(this.infoEntries, optimizeAction.infoEntries) &&
        Objects.equals(this.flattenSignatureFields, optimizeAction.flattenSignatureFields) &&
        Objects.equals(this.customProperties, optimizeAction.customProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(profile, useProfile, removeRedundantObjects, subsetFonts, optimizeResources, forceCompressionTypes, forceRecompression, reduceColorComplexity, mergeEmbeddedFonts, bitonalCompressions, bitonalResolutionDPI, bitonalThresholdDPI, clipImages, continuousCompressions, linearize, imageQuality, indexedCompressions, ditheringMode, colorResolutionDPI, colorThresholdDPI, monochromeResolutionDPI, monochromeThresholdDPI, resolutionDPI, thresholdDPI, strip, infoEntries, flattenSignatureFields, customProperties);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OptimizeAction {\n");
    
    sb.append("    profile: ").append(toIndentedString(profile)).append("\n");
    sb.append("    useProfile: ").append(toIndentedString(useProfile)).append("\n");
    sb.append("    removeRedundantObjects: ").append(toIndentedString(removeRedundantObjects)).append("\n");
    sb.append("    subsetFonts: ").append(toIndentedString(subsetFonts)).append("\n");
    sb.append("    optimizeResources: ").append(toIndentedString(optimizeResources)).append("\n");
    sb.append("    forceCompressionTypes: ").append(toIndentedString(forceCompressionTypes)).append("\n");
    sb.append("    forceRecompression: ").append(toIndentedString(forceRecompression)).append("\n");
    sb.append("    reduceColorComplexity: ").append(toIndentedString(reduceColorComplexity)).append("\n");
    sb.append("    mergeEmbeddedFonts: ").append(toIndentedString(mergeEmbeddedFonts)).append("\n");
    sb.append("    bitonalCompressions: ").append(toIndentedString(bitonalCompressions)).append("\n");
    sb.append("    bitonalResolutionDPI: ").append(toIndentedString(bitonalResolutionDPI)).append("\n");
    sb.append("    bitonalThresholdDPI: ").append(toIndentedString(bitonalThresholdDPI)).append("\n");
    sb.append("    clipImages: ").append(toIndentedString(clipImages)).append("\n");
    sb.append("    continuousCompressions: ").append(toIndentedString(continuousCompressions)).append("\n");
    sb.append("    linearize: ").append(toIndentedString(linearize)).append("\n");
    sb.append("    imageQuality: ").append(toIndentedString(imageQuality)).append("\n");
    sb.append("    indexedCompressions: ").append(toIndentedString(indexedCompressions)).append("\n");
    sb.append("    ditheringMode: ").append(toIndentedString(ditheringMode)).append("\n");
    sb.append("    colorResolutionDPI: ").append(toIndentedString(colorResolutionDPI)).append("\n");
    sb.append("    colorThresholdDPI: ").append(toIndentedString(colorThresholdDPI)).append("\n");
    sb.append("    monochromeResolutionDPI: ").append(toIndentedString(monochromeResolutionDPI)).append("\n");
    sb.append("    monochromeThresholdDPI: ").append(toIndentedString(monochromeThresholdDPI)).append("\n");
    sb.append("    resolutionDPI: ").append(toIndentedString(resolutionDPI)).append("\n");
    sb.append("    thresholdDPI: ").append(toIndentedString(thresholdDPI)).append("\n");
    sb.append("    strip: ").append(toIndentedString(strip)).append("\n");
    sb.append("    infoEntries: ").append(toIndentedString(infoEntries)).append("\n");
    sb.append("    flattenSignatureFields: ").append(toIndentedString(flattenSignatureFields)).append("\n");
    sb.append("    customProperties: ").append(toIndentedString(customProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

